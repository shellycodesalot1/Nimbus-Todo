{"ast":null,"code":"/*! @azure/msal-browser v4.11.0 2025-04-16 */\n'use strict';\n\nimport { CacheManager, AccountEntity, invokeAsync, PerformanceEvents, CredentialType, createClientAuthError, ClientAuthErrorCodes, CacheHelpers, Constants, PersistentCacheKeys, StringUtils, TimeUtils, CacheError, DEFAULT_CRYPTO_IMPLEMENTATION } from '@azure/msal-common/browser';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { BrowserCacheLocation, StaticCacheKeys, InMemoryCacheKeys, TemporaryCacheKeys, INTERACTION_TYPE } from '../utils/BrowserConstants.mjs';\nimport { LocalStorage } from './LocalStorage.mjs';\nimport { SessionStorage } from './SessionStorage.mjs';\nimport { MemoryStorage } from './MemoryStorage.mjs';\nimport { base64Decode } from '../encode/Base64Decode.mjs';\nimport { base64Encode } from '../encode/Base64Encode.mjs';\nimport { CookieStorage } from './CookieStorage.mjs';\nimport { getAccountKeys, getTokenKeys } from './CacheHelpers.mjs';\nimport { EventType } from '../event/EventType.mjs';\nimport { noTokenRequestCacheError, unableToParseTokenRequestCacheError, interactionInProgress } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * This class implements the cache storage interface for MSAL through browser local or session storage.\r\n * Cookies are only used if storeAuthStateInCookie is true, and are only used for\r\n * parameters such as state and nonce, generally.\r\n */\nclass BrowserCacheManager extends CacheManager {\n  constructor(clientId, cacheConfig, cryptoImpl, logger, performanceClient, eventHandler, staticAuthorityOptions) {\n    super(clientId, cryptoImpl, logger, staticAuthorityOptions);\n    this.cacheConfig = cacheConfig;\n    this.logger = logger;\n    this.internalStorage = new MemoryStorage();\n    this.browserStorage = getStorageImplementation(clientId, cacheConfig.cacheLocation, logger, performanceClient);\n    this.temporaryCacheStorage = getStorageImplementation(clientId, cacheConfig.temporaryCacheLocation, logger, performanceClient);\n    this.cookieStorage = new CookieStorage();\n    this.performanceClient = performanceClient;\n    this.eventHandler = eventHandler;\n  }\n  async initialize(correlationId) {\n    await this.browserStorage.initialize(correlationId);\n  }\n  /**\r\n   * Parses passed value as JSON object, JSON.parse() will throw an error.\r\n   * @param input\r\n   */\n  validateAndParseJson(jsonValue) {\n    try {\n      const parsedJson = JSON.parse(jsonValue);\n      /**\r\n       * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\r\n       * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\r\n       * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\r\n       *\r\n       */\n      return parsedJson && typeof parsedJson === \"object\" ? parsedJson : null;\n    } catch (error) {\n      return null;\n    }\n  }\n  /**\r\n   * Reads account from cache, deserializes it into an account entity and returns it.\r\n   * If account is not found from the key, returns null and removes key from map.\r\n   * @param accountKey\r\n   * @returns\r\n   */\n  getAccount(accountKey) {\n    this.logger.trace(\"BrowserCacheManager.getAccount called\");\n    const serializedAccount = this.browserStorage.getUserData(accountKey);\n    if (!serializedAccount) {\n      this.removeAccountKeyFromMap(accountKey);\n      return null;\n    }\n    const parsedAccount = this.validateAndParseJson(serializedAccount);\n    if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {\n      this.removeAccountKeyFromMap(accountKey);\n      return null;\n    }\n    return CacheManager.toObject(new AccountEntity(), parsedAccount);\n  }\n  /**\r\n   * set account entity in the platform cache\r\n   * @param account\r\n   */\n  async setAccount(account, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setAccount called\");\n    const key = account.generateAccountKey();\n    await invokeAsync(this.browserStorage.setUserData.bind(this.browserStorage), PerformanceEvents.SetUserData, this.logger, this.performanceClient)(key, JSON.stringify(account), correlationId);\n    const wasAdded = this.addAccountKeyToMap(key);\n    /**\r\n     * @deprecated - Remove this in next major version in favor of more consistent LOGIN event\r\n     */\n    if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage && wasAdded) {\n      this.eventHandler.emitEvent(EventType.ACCOUNT_ADDED, undefined, account.getAccountInfo());\n    }\n  }\n  /**\r\n   * Returns the array of account keys currently cached\r\n   * @returns\r\n   */\n  getAccountKeys() {\n    return getAccountKeys(this.browserStorage);\n  }\n  /**\r\n   * Add a new account to the key map\r\n   * @param key\r\n   */\n  addAccountKeyToMap(key) {\n    this.logger.trace(\"BrowserCacheManager.addAccountKeyToMap called\");\n    this.logger.tracePii(`BrowserCacheManager.addAccountKeyToMap called with key: ${key}`);\n    const accountKeys = this.getAccountKeys();\n    if (accountKeys.indexOf(key) === -1) {\n      // Only add key if it does not already exist in the map\n      accountKeys.push(key);\n      this.browserStorage.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));\n      this.logger.verbose(\"BrowserCacheManager.addAccountKeyToMap account key added\");\n      return true;\n    } else {\n      this.logger.verbose(\"BrowserCacheManager.addAccountKeyToMap account key already exists in map\");\n      return false;\n    }\n  }\n  /**\r\n   * Remove an account from the key map\r\n   * @param key\r\n   */\n  removeAccountKeyFromMap(key) {\n    this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap called\");\n    this.logger.tracePii(`BrowserCacheManager.removeAccountKeyFromMap called with key: ${key}`);\n    const accountKeys = this.getAccountKeys();\n    const removalIndex = accountKeys.indexOf(key);\n    if (removalIndex > -1) {\n      accountKeys.splice(removalIndex, 1);\n      this.browserStorage.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));\n      this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap account key removed\");\n    } else {\n      this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap key not found in existing map\");\n    }\n  }\n  /**\r\n   * Extends inherited removeAccount function to include removal of the account key from the map\r\n   * @param key\r\n   */\n  async removeAccount(key) {\n    void super.removeAccount(key);\n    this.removeAccountKeyFromMap(key);\n  }\n  /**\r\n   * Removes credentials associated with the provided account\r\n   * @param account\r\n   */\n  async removeAccountContext(account) {\n    await super.removeAccountContext(account);\n    /**\r\n     * @deprecated - Remove this in next major version in favor of more consistent LOGOUT event\r\n     */\n    if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {\n      this.eventHandler.emitEvent(EventType.ACCOUNT_REMOVED, undefined, account.getAccountInfo());\n    }\n  }\n  /**\r\n   * Removes given idToken from the cache and from the key map\r\n   * @param key\r\n   */\n  removeIdToken(key) {\n    super.removeIdToken(key);\n    this.removeTokenKey(key, CredentialType.ID_TOKEN);\n  }\n  /**\r\n   * Removes given accessToken from the cache and from the key map\r\n   * @param key\r\n   */\n  async removeAccessToken(key) {\n    void super.removeAccessToken(key);\n    this.removeTokenKey(key, CredentialType.ACCESS_TOKEN);\n  }\n  /**\r\n   * Removes given refreshToken from the cache and from the key map\r\n   * @param key\r\n   */\n  removeRefreshToken(key) {\n    super.removeRefreshToken(key);\n    this.removeTokenKey(key, CredentialType.REFRESH_TOKEN);\n  }\n  /**\r\n   * Gets the keys for the cached tokens associated with this clientId\r\n   * @returns\r\n   */\n  getTokenKeys() {\n    return getTokenKeys(this.clientId, this.browserStorage);\n  }\n  /**\r\n   * Adds the given key to the token key map\r\n   * @param key\r\n   * @param type\r\n   */\n  addTokenKey(key, type) {\n    this.logger.trace(\"BrowserCacheManager addTokenKey called\");\n    const tokenKeys = this.getTokenKeys();\n    switch (type) {\n      case CredentialType.ID_TOKEN:\n        if (tokenKeys.idToken.indexOf(key) === -1) {\n          this.logger.info(\"BrowserCacheManager: addTokenKey - idToken added to map\");\n          tokenKeys.idToken.push(key);\n        }\n        break;\n      case CredentialType.ACCESS_TOKEN:\n        if (tokenKeys.accessToken.indexOf(key) === -1) {\n          this.logger.info(\"BrowserCacheManager: addTokenKey - accessToken added to map\");\n          tokenKeys.accessToken.push(key);\n        }\n        break;\n      case CredentialType.REFRESH_TOKEN:\n        if (tokenKeys.refreshToken.indexOf(key) === -1) {\n          this.logger.info(\"BrowserCacheManager: addTokenKey - refreshToken added to map\");\n          tokenKeys.refreshToken.push(key);\n        }\n        break;\n      default:\n        this.logger.error(`BrowserCacheManager:addTokenKey - CredentialType provided invalid. CredentialType: ${type}`);\n        throw createClientAuthError(ClientAuthErrorCodes.unexpectedCredentialType);\n    }\n    this.browserStorage.setItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`, JSON.stringify(tokenKeys));\n  }\n  /**\r\n   * Removes the given key from the token key map\r\n   * @param key\r\n   * @param type\r\n   */\n  removeTokenKey(key, type) {\n    this.logger.trace(\"BrowserCacheManager removeTokenKey called\");\n    const tokenKeys = this.getTokenKeys();\n    switch (type) {\n      case CredentialType.ID_TOKEN:\n        this.logger.infoPii(`BrowserCacheManager: removeTokenKey - attempting to remove idToken with key: ${key} from map`);\n        const idRemoval = tokenKeys.idToken.indexOf(key);\n        if (idRemoval > -1) {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - idToken removed from map\");\n          tokenKeys.idToken.splice(idRemoval, 1);\n        } else {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - idToken does not exist in map. Either it was previously removed or it was never added.\");\n        }\n        break;\n      case CredentialType.ACCESS_TOKEN:\n        this.logger.infoPii(`BrowserCacheManager: removeTokenKey - attempting to remove accessToken with key: ${key} from map`);\n        const accessRemoval = tokenKeys.accessToken.indexOf(key);\n        if (accessRemoval > -1) {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - accessToken removed from map\");\n          tokenKeys.accessToken.splice(accessRemoval, 1);\n        } else {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - accessToken does not exist in map. Either it was previously removed or it was never added.\");\n        }\n        break;\n      case CredentialType.REFRESH_TOKEN:\n        this.logger.infoPii(`BrowserCacheManager: removeTokenKey - attempting to remove refreshToken with key: ${key} from map`);\n        const refreshRemoval = tokenKeys.refreshToken.indexOf(key);\n        if (refreshRemoval > -1) {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - refreshToken removed from map\");\n          tokenKeys.refreshToken.splice(refreshRemoval, 1);\n        } else {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - refreshToken does not exist in map. Either it was previously removed or it was never added.\");\n        }\n        break;\n      default:\n        this.logger.error(`BrowserCacheManager:removeTokenKey - CredentialType provided invalid. CredentialType: ${type}`);\n        throw createClientAuthError(ClientAuthErrorCodes.unexpectedCredentialType);\n    }\n    this.browserStorage.setItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`, JSON.stringify(tokenKeys));\n  }\n  /**\r\n   * generates idToken entity from a string\r\n   * @param idTokenKey\r\n   */\n  getIdTokenCredential(idTokenKey) {\n    const value = this.browserStorage.getUserData(idTokenKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n      this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n      return null;\n    }\n    const parsedIdToken = this.validateAndParseJson(value);\n    if (!parsedIdToken || !CacheHelpers.isIdTokenEntity(parsedIdToken)) {\n      this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n      this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: cache hit\");\n    return parsedIdToken;\n  }\n  /**\r\n   * set IdToken credential to the platform cache\r\n   * @param idToken\r\n   */\n  async setIdTokenCredential(idToken, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setIdTokenCredential called\");\n    const idTokenKey = CacheHelpers.generateCredentialKey(idToken);\n    await invokeAsync(this.browserStorage.setUserData.bind(this.browserStorage), PerformanceEvents.SetUserData, this.logger, this.performanceClient)(idTokenKey, JSON.stringify(idToken), correlationId);\n    this.addTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n  }\n  /**\r\n   * generates accessToken entity from a string\r\n   * @param key\r\n   */\n  getAccessTokenCredential(accessTokenKey) {\n    const value = this.browserStorage.getUserData(accessTokenKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n      this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n      return null;\n    }\n    const parsedAccessToken = this.validateAndParseJson(value);\n    if (!parsedAccessToken || !CacheHelpers.isAccessTokenEntity(parsedAccessToken)) {\n      this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n      this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: cache hit\");\n    return parsedAccessToken;\n  }\n  /**\r\n   * set accessToken credential to the platform cache\r\n   * @param accessToken\r\n   */\n  async setAccessTokenCredential(accessToken, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setAccessTokenCredential called\");\n    const accessTokenKey = CacheHelpers.generateCredentialKey(accessToken);\n    await invokeAsync(this.browserStorage.setUserData.bind(this.browserStorage), PerformanceEvents.SetUserData, this.logger, this.performanceClient)(accessTokenKey, JSON.stringify(accessToken), correlationId);\n    this.addTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n  }\n  /**\r\n   * generates refreshToken entity from a string\r\n   * @param refreshTokenKey\r\n   */\n  getRefreshTokenCredential(refreshTokenKey) {\n    const value = this.browserStorage.getUserData(refreshTokenKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n      this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n      return null;\n    }\n    const parsedRefreshToken = this.validateAndParseJson(value);\n    if (!parsedRefreshToken || !CacheHelpers.isRefreshTokenEntity(parsedRefreshToken)) {\n      this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n      this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: cache hit\");\n    return parsedRefreshToken;\n  }\n  /**\r\n   * set refreshToken credential to the platform cache\r\n   * @param refreshToken\r\n   */\n  async setRefreshTokenCredential(refreshToken, correlationId) {\n    this.logger.trace(\"BrowserCacheManager.setRefreshTokenCredential called\");\n    const refreshTokenKey = CacheHelpers.generateCredentialKey(refreshToken);\n    await invokeAsync(this.browserStorage.setUserData.bind(this.browserStorage), PerformanceEvents.SetUserData, this.logger, this.performanceClient)(refreshTokenKey, JSON.stringify(refreshToken), correlationId);\n    this.addTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n  }\n  /**\r\n   * fetch appMetadata entity from the platform cache\r\n   * @param appMetadataKey\r\n   */\n  getAppMetadata(appMetadataKey) {\n    const value = this.browserStorage.getItem(appMetadataKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n      return null;\n    }\n    const parsedMetadata = this.validateAndParseJson(value);\n    if (!parsedMetadata || !CacheHelpers.isAppMetadataEntity(appMetadataKey, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getAppMetadata: cache hit\");\n    return parsedMetadata;\n  }\n  /**\r\n   * set appMetadata entity to the platform cache\r\n   * @param appMetadata\r\n   */\n  setAppMetadata(appMetadata) {\n    this.logger.trace(\"BrowserCacheManager.setAppMetadata called\");\n    const appMetadataKey = CacheHelpers.generateAppMetadataKey(appMetadata);\n    this.browserStorage.setItem(appMetadataKey, JSON.stringify(appMetadata));\n  }\n  /**\r\n   * fetch server telemetry entity from the platform cache\r\n   * @param serverTelemetryKey\r\n   */\n  getServerTelemetry(serverTelemetryKey) {\n    const value = this.browserStorage.getItem(serverTelemetryKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n      return null;\n    }\n    const parsedEntity = this.validateAndParseJson(value);\n    if (!parsedEntity || !CacheHelpers.isServerTelemetryEntity(serverTelemetryKey, parsedEntity)) {\n      this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getServerTelemetry: cache hit\");\n    return parsedEntity;\n  }\n  /**\r\n   * set server telemetry entity to the platform cache\r\n   * @param serverTelemetryKey\r\n   * @param serverTelemetry\r\n   */\n  setServerTelemetry(serverTelemetryKey, serverTelemetry) {\n    this.logger.trace(\"BrowserCacheManager.setServerTelemetry called\");\n    this.browserStorage.setItem(serverTelemetryKey, JSON.stringify(serverTelemetry));\n  }\n  /**\r\n   *\r\n   */\n  getAuthorityMetadata(key) {\n    const value = this.internalStorage.getItem(key);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: called, no cache hit\");\n      return null;\n    }\n    const parsedMetadata = this.validateAndParseJson(value);\n    if (parsedMetadata && CacheHelpers.isAuthorityMetadataEntity(key, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: cache hit\");\n      return parsedMetadata;\n    }\n    return null;\n  }\n  /**\r\n   *\r\n   */\n  getAuthorityMetadataKeys() {\n    const allKeys = this.internalStorage.getKeys();\n    return allKeys.filter(key => {\n      return this.isAuthorityMetadata(key);\n    });\n  }\n  /**\r\n   * Sets wrapper metadata in memory\r\n   * @param wrapperSKU\r\n   * @param wrapperVersion\r\n   */\n  setWrapperMetadata(wrapperSKU, wrapperVersion) {\n    this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, wrapperSKU);\n    this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_VER, wrapperVersion);\n  }\n  /**\r\n   * Returns wrapper metadata from in-memory storage\r\n   */\n  getWrapperMetadata() {\n    const sku = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) || Constants.EMPTY_STRING;\n    const version = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) || Constants.EMPTY_STRING;\n    return [sku, version];\n  }\n  /**\r\n   *\r\n   * @param entity\r\n   */\n  setAuthorityMetadata(key, entity) {\n    this.logger.trace(\"BrowserCacheManager.setAuthorityMetadata called\");\n    this.internalStorage.setItem(key, JSON.stringify(entity));\n  }\n  /**\r\n   * Gets the active account\r\n   */\n  getActiveAccount() {\n    const activeAccountKeyFilters = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\n    const activeAccountValueFilters = this.browserStorage.getItem(activeAccountKeyFilters);\n    if (!activeAccountValueFilters) {\n      this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account filters found\");\n      return null;\n    }\n    const activeAccountValueObj = this.validateAndParseJson(activeAccountValueFilters);\n    if (activeAccountValueObj) {\n      this.logger.trace(\"BrowserCacheManager.getActiveAccount: Active account filters schema found\");\n      return this.getAccountInfoFilteredBy({\n        homeAccountId: activeAccountValueObj.homeAccountId,\n        localAccountId: activeAccountValueObj.localAccountId,\n        tenantId: activeAccountValueObj.tenantId\n      });\n    }\n    this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account found\");\n    return null;\n  }\n  /**\r\n   * Sets the active account's localAccountId in cache\r\n   * @param account\r\n   */\n  setActiveAccount(account) {\n    const activeAccountKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\n    if (account) {\n      this.logger.verbose(\"setActiveAccount: Active account set\");\n      const activeAccountValue = {\n        homeAccountId: account.homeAccountId,\n        localAccountId: account.localAccountId,\n        tenantId: account.tenantId\n      };\n      this.browserStorage.setItem(activeAccountKey, JSON.stringify(activeAccountValue));\n    } else {\n      this.logger.verbose(\"setActiveAccount: No account passed, active account not set\");\n      this.browserStorage.removeItem(activeAccountKey);\n    }\n    this.eventHandler.emitEvent(EventType.ACTIVE_ACCOUNT_CHANGED);\n  }\n  /**\r\n   * fetch throttling entity from the platform cache\r\n   * @param throttlingCacheKey\r\n   */\n  getThrottlingCache(throttlingCacheKey) {\n    const value = this.browserStorage.getItem(throttlingCacheKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n      return null;\n    }\n    const parsedThrottlingCache = this.validateAndParseJson(value);\n    if (!parsedThrottlingCache || !CacheHelpers.isThrottlingEntity(throttlingCacheKey, parsedThrottlingCache)) {\n      this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getThrottlingCache: cache hit\");\n    return parsedThrottlingCache;\n  }\n  /**\r\n   * set throttling entity to the platform cache\r\n   * @param throttlingCacheKey\r\n   * @param throttlingCache\r\n   */\n  setThrottlingCache(throttlingCacheKey, throttlingCache) {\n    this.logger.trace(\"BrowserCacheManager.setThrottlingCache called\");\n    this.browserStorage.setItem(throttlingCacheKey, JSON.stringify(throttlingCache));\n  }\n  /**\r\n   * Gets cache item with given key.\r\n   * Will retrieve from cookies if storeAuthStateInCookie is set to true.\r\n   * @param key\r\n   */\n  getTemporaryCache(cacheKey, generateKey) {\n    const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      const itemCookie = this.cookieStorage.getItem(key);\n      if (itemCookie) {\n        this.logger.trace(\"BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies\");\n        return itemCookie;\n      }\n    }\n    const value = this.temporaryCacheStorage.getItem(key);\n    if (!value) {\n      // If temp cache item not found in session/memory, check local storage for items set by old versions\n      if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {\n        const item = this.browserStorage.getItem(key);\n        if (item) {\n          this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage\");\n          return item;\n        }\n      }\n      this.logger.trace(\"BrowserCacheManager.getTemporaryCache: No cache item found in local storage\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item returned\");\n    return value;\n  }\n  /**\r\n   * Sets the cache item with the key and value given.\r\n   * Stores in cookie if storeAuthStateInCookie is set to true.\r\n   * This can cause cookie overflow if used incorrectly.\r\n   * @param key\r\n   * @param value\r\n   */\n  setTemporaryCache(cacheKey, value, generateKey) {\n    const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n    this.temporaryCacheStorage.setItem(key, value);\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      this.logger.trace(\"BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie\");\n      this.cookieStorage.setItem(key, value, undefined, this.cacheConfig.secureCookies);\n    }\n  }\n  /**\r\n   * Removes the cache item with the given key.\r\n   * @param key\r\n   */\n  removeItem(key) {\n    this.browserStorage.removeItem(key);\n  }\n  /**\r\n   * Removes the temporary cache item with the given key.\r\n   * Will also clear the cookie item if storeAuthStateInCookie is set to true.\r\n   * @param key\r\n   */\n  removeTemporaryItem(key) {\n    this.temporaryCacheStorage.removeItem(key);\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      this.logger.trace(\"BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie\");\n      this.cookieStorage.removeItem(key);\n    }\n  }\n  /**\r\n   * Gets all keys in window.\r\n   */\n  getKeys() {\n    return this.browserStorage.getKeys();\n  }\n  /**\r\n   * Clears all cache entries created by MSAL.\r\n   */\n  async clear() {\n    // Removes all accounts and their credentials\n    await this.removeAllAccounts();\n    this.removeAppMetadata();\n    // Remove temp storage first to make sure any cookies are cleared\n    this.temporaryCacheStorage.getKeys().forEach(cacheKey => {\n      if (cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 || cacheKey.indexOf(this.clientId) !== -1) {\n        this.removeTemporaryItem(cacheKey);\n      }\n    });\n    // Removes all remaining MSAL cache items\n    this.browserStorage.getKeys().forEach(cacheKey => {\n      if (cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 || cacheKey.indexOf(this.clientId) !== -1) {\n        this.browserStorage.removeItem(cacheKey);\n      }\n    });\n    this.internalStorage.clear();\n  }\n  /**\r\n   * Clears all access tokes that have claims prior to saving the current one\r\n   * @param performanceClient {IPerformanceClient}\r\n   * @param correlationId {string} correlation id\r\n   * @returns\r\n   */\n  async clearTokensAndKeysWithClaims(performanceClient, correlationId) {\n    performanceClient.addQueueMeasurement(PerformanceEvents.ClearTokensAndKeysWithClaims, correlationId);\n    const tokenKeys = this.getTokenKeys();\n    const removedAccessTokens = [];\n    tokenKeys.accessToken.forEach(key => {\n      // if the access token has claims in its key, remove the token key and the token\n      const credential = this.getAccessTokenCredential(key);\n      if (credential?.requestedClaimsHash && key.includes(credential.requestedClaimsHash.toLowerCase())) {\n        removedAccessTokens.push(this.removeAccessToken(key));\n      }\n    });\n    await Promise.all(removedAccessTokens);\n    // warn if any access tokens are removed\n    if (removedAccessTokens.length > 0) {\n      this.logger.warning(`${removedAccessTokens.length} access tokens with claims in the cache keys have been removed from the cache.`);\n    }\n  }\n  /**\r\n   * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\r\n   * @param key\r\n   * @param addInstanceId\r\n   */\n  generateCacheKey(key) {\n    const generatedKey = this.validateAndParseJson(key);\n    if (!generatedKey) {\n      if (StringUtils.startsWith(key, Constants.CACHE_PREFIX)) {\n        return key;\n      }\n      return `${Constants.CACHE_PREFIX}.${this.clientId}.${key}`;\n    }\n    return JSON.stringify(key);\n  }\n  /**\r\n   * Reset all temporary cache items\r\n   * @param state\r\n   */\n  resetRequestCache() {\n    this.logger.trace(\"BrowserCacheManager.resetRequestCache called\");\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.VERIFIER));\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI));\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.URL_HASH));\n    this.removeTemporaryItem(this.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST));\n    this.setInteractionInProgress(false);\n  }\n  cacheAuthorizeRequest(authCodeRequest, codeVerifier) {\n    this.logger.trace(\"BrowserCacheManager.cacheAuthorizeRequest called\");\n    const encodedValue = base64Encode(JSON.stringify(authCodeRequest));\n    this.setTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, encodedValue, true);\n    if (codeVerifier) {\n      const encodedVerifier = base64Encode(codeVerifier);\n      this.setTemporaryCache(TemporaryCacheKeys.VERIFIER, encodedVerifier, true);\n    }\n  }\n  /**\r\n   * Gets the token exchange parameters from the cache. Throws an error if nothing is found.\r\n   */\n  getCachedRequest() {\n    this.logger.trace(\"BrowserCacheManager.getCachedRequest called\");\n    // Get token request from cache and parse as TokenExchangeParameters.\n    const encodedTokenRequest = this.getTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, true);\n    if (!encodedTokenRequest) {\n      throw createBrowserAuthError(noTokenRequestCacheError);\n    }\n    const encodedVerifier = this.getTemporaryCache(TemporaryCacheKeys.VERIFIER, true);\n    let parsedRequest;\n    let verifier = \"\";\n    try {\n      parsedRequest = JSON.parse(base64Decode(encodedTokenRequest));\n      if (encodedVerifier) {\n        verifier = base64Decode(encodedVerifier);\n      }\n    } catch (e) {\n      this.logger.errorPii(`Attempted to parse: ${encodedTokenRequest}`);\n      this.logger.error(`Parsing cached token request threw with error: ${e}`);\n      throw createBrowserAuthError(unableToParseTokenRequestCacheError);\n    }\n    return [parsedRequest, verifier];\n  }\n  /**\r\n   * Gets cached native request for redirect flows\r\n   */\n  getCachedNativeRequest() {\n    this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest called\");\n    const cachedRequest = this.getTemporaryCache(TemporaryCacheKeys.NATIVE_REQUEST, true);\n    if (!cachedRequest) {\n      this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest: No cached native request found\");\n      return null;\n    }\n    const parsedRequest = this.validateAndParseJson(cachedRequest);\n    if (!parsedRequest) {\n      this.logger.error(\"BrowserCacheManager.getCachedNativeRequest: Unable to parse native request\");\n      return null;\n    }\n    return parsedRequest;\n  }\n  isInteractionInProgress(matchClientId) {\n    const clientId = this.getInteractionInProgress()?.clientId;\n    if (matchClientId) {\n      return clientId === this.clientId;\n    } else {\n      return !!clientId;\n    }\n  }\n  getInteractionInProgress() {\n    const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\n    const value = this.getTemporaryCache(key, false);\n    return value ? JSON.parse(value) : null;\n  }\n  setInteractionInProgress(inProgress, type = INTERACTION_TYPE.SIGNIN) {\n    // Ensure we don't overwrite interaction in progress for a different clientId\n    const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\n    if (inProgress) {\n      if (this.getInteractionInProgress()) {\n        throw createBrowserAuthError(interactionInProgress);\n      } else {\n        // No interaction is in progress\n        this.setTemporaryCache(key, JSON.stringify({\n          clientId: this.clientId,\n          type\n        }), false);\n      }\n    } else if (!inProgress && this.getInteractionInProgress()?.clientId === this.clientId) {\n      this.removeTemporaryItem(key);\n    }\n  }\n  /**\r\n   * Builds credential entities from AuthenticationResult object and saves the resulting credentials to the cache\r\n   * @param result\r\n   * @param request\r\n   */\n  async hydrateCache(result, request) {\n    const idTokenEntity = CacheHelpers.createIdTokenEntity(result.account?.homeAccountId, result.account?.environment, result.idToken, this.clientId, result.tenantId);\n    let claimsHash;\n    if (request.claims) {\n      claimsHash = await this.cryptoImpl.hashString(request.claims);\n    }\n    /**\r\n     * meta data for cache stores time in seconds from epoch\r\n     * AuthenticationResult returns expiresOn and extExpiresOn in milliseconds (as a Date object which is in ms)\r\n     * We need to map these for the cache when building tokens from AuthenticationResult\r\n     *\r\n     * The next MSAL VFuture should map these both to same value if possible\r\n     */\n    const accessTokenEntity = CacheHelpers.createAccessTokenEntity(result.account?.homeAccountId, result.account.environment, result.accessToken, this.clientId, result.tenantId, result.scopes.join(\" \"),\n    // Access token expiresOn stored in seconds, converting from AuthenticationResult expiresOn stored as Date\n    result.expiresOn ? TimeUtils.toSecondsFromDate(result.expiresOn) : 0, result.extExpiresOn ? TimeUtils.toSecondsFromDate(result.extExpiresOn) : 0, base64Decode, undefined,\n    // refreshOn\n    result.tokenType, undefined,\n    // userAssertionHash\n    request.sshKid, request.claims, claimsHash);\n    const cacheRecord = {\n      idToken: idTokenEntity,\n      accessToken: accessTokenEntity\n    };\n    return this.saveCacheRecord(cacheRecord, result.correlationId);\n  }\n  /**\r\n   * saves a cache record\r\n   * @param cacheRecord {CacheRecord}\r\n   * @param storeInCache {?StoreInCache}\r\n   * @param correlationId {?string} correlation id\r\n   */\n  async saveCacheRecord(cacheRecord, correlationId, storeInCache) {\n    try {\n      await super.saveCacheRecord(cacheRecord, correlationId, storeInCache);\n    } catch (e) {\n      if (e instanceof CacheError && this.performanceClient && correlationId) {\n        try {\n          const tokenKeys = this.getTokenKeys();\n          this.performanceClient.addFields({\n            cacheRtCount: tokenKeys.refreshToken.length,\n            cacheIdCount: tokenKeys.idToken.length,\n            cacheAtCount: tokenKeys.accessToken.length\n          }, correlationId);\n        } catch (e) {}\n      }\n      throw e;\n    }\n  }\n}\n/**\r\n * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.\r\n * @param cacheLocation\r\n */\nfunction getStorageImplementation(clientId, cacheLocation, logger, performanceClient) {\n  try {\n    switch (cacheLocation) {\n      case BrowserCacheLocation.LocalStorage:\n        return new LocalStorage(clientId, logger, performanceClient);\n      case BrowserCacheLocation.SessionStorage:\n        return new SessionStorage();\n      case BrowserCacheLocation.MemoryStorage:\n      default:\n        break;\n    }\n  } catch (e) {\n    logger.error(e);\n  }\n  return new MemoryStorage();\n}\nconst DEFAULT_BROWSER_CACHE_MANAGER = (clientId, logger, performanceClient, eventHandler) => {\n  const cacheOptions = {\n    cacheLocation: BrowserCacheLocation.MemoryStorage,\n    temporaryCacheLocation: BrowserCacheLocation.MemoryStorage,\n    storeAuthStateInCookie: false,\n    secureCookies: false,\n    cacheMigrationEnabled: false,\n    claimsBasedCachingEnabled: false\n  };\n  return new BrowserCacheManager(clientId, cacheOptions, DEFAULT_CRYPTO_IMPLEMENTATION, logger, performanceClient, eventHandler);\n};\nexport { BrowserCacheManager, DEFAULT_BROWSER_CACHE_MANAGER };","map":{"version":3,"names":["BrowserCacheManager","CacheManager","constructor","clientId","cacheConfig","cryptoImpl","logger","performanceClient","eventHandler","staticAuthorityOptions","internalStorage","MemoryStorage","browserStorage","getStorageImplementation","cacheLocation","temporaryCacheStorage","temporaryCacheLocation","cookieStorage","CookieStorage","initialize","correlationId","validateAndParseJson","jsonValue","parsedJson","JSON","parse","error","getAccount","accountKey","trace","serializedAccount","getUserData","removeAccountKeyFromMap","parsedAccount","AccountEntity","isAccountEntity","toObject","setAccount","account","key","generateAccountKey","invokeAsync","setUserData","bind","PerformanceEvents","SetUserData","stringify","wasAdded","addAccountKeyToMap","BrowserCacheLocation","LocalStorage","emitEvent","EventType","ACCOUNT_ADDED","undefined","getAccountInfo","getAccountKeys","tracePii","accountKeys","indexOf","push","setItem","StaticCacheKeys","ACCOUNT_KEYS","verbose","removalIndex","splice","removeAccount","removeAccountContext","ACCOUNT_REMOVED","removeIdToken","removeTokenKey","CredentialType","ID_TOKEN","removeAccessToken","ACCESS_TOKEN","removeRefreshToken","REFRESH_TOKEN","getTokenKeys","addTokenKey","type","tokenKeys","idToken","info","accessToken","refreshToken","createClientAuthError","ClientAuthErrorCodes","unexpectedCredentialType","TOKEN_KEYS","infoPii","idRemoval","accessRemoval","refreshRemoval","getIdTokenCredential","idTokenKey","value","parsedIdToken","CacheHelpers","isIdTokenEntity","setIdTokenCredential","generateCredentialKey","getAccessTokenCredential","accessTokenKey","parsedAccessToken","isAccessTokenEntity","setAccessTokenCredential","getRefreshTokenCredential","refreshTokenKey","parsedRefreshToken","isRefreshTokenEntity","setRefreshTokenCredential","getAppMetadata","appMetadataKey","getItem","parsedMetadata","isAppMetadataEntity","setAppMetadata","appMetadata","generateAppMetadataKey","getServerTelemetry","serverTelemetryKey","parsedEntity","isServerTelemetryEntity","setServerTelemetry","serverTelemetry","getAuthorityMetadata","isAuthorityMetadataEntity","getAuthorityMetadataKeys","allKeys","getKeys","filter","isAuthorityMetadata","setWrapperMetadata","wrapperSKU","wrapperVersion","InMemoryCacheKeys","WRAPPER_SKU","WRAPPER_VER","getWrapperMetadata","sku","Constants","EMPTY_STRING","version","setAuthorityMetadata","entity","getActiveAccount","activeAccountKeyFilters","generateCacheKey","PersistentCacheKeys","ACTIVE_ACCOUNT_FILTERS","activeAccountValueFilters","activeAccountValueObj","getAccountInfoFilteredBy","homeAccountId","localAccountId","tenantId","setActiveAccount","activeAccountKey","activeAccountValue","removeItem","ACTIVE_ACCOUNT_CHANGED","getThrottlingCache","throttlingCacheKey","parsedThrottlingCache","isThrottlingEntity","setThrottlingCache","throttlingCache","getTemporaryCache","cacheKey","generateKey","storeAuthStateInCookie","itemCookie","item","setTemporaryCache","secureCookies","removeTemporaryItem","clear","removeAllAccounts","removeAppMetadata","forEach","CACHE_PREFIX","clearTokensAndKeysWithClaims","addQueueMeasurement","ClearTokensAndKeysWithClaims","removedAccessTokens","credential","requestedClaimsHash","includes","toLowerCase","Promise","all","length","warning","generatedKey","StringUtils","startsWith","resetRequestCache","TemporaryCacheKeys","REQUEST_PARAMS","VERIFIER","ORIGIN_URI","URL_HASH","NATIVE_REQUEST","setInteractionInProgress","cacheAuthorizeRequest","authCodeRequest","codeVerifier","encodedValue","base64Encode","encodedVerifier","getCachedRequest","encodedTokenRequest","createBrowserAuthError","noTokenRequestCacheError","parsedRequest","verifier","base64Decode","e","errorPii","unableToParseTokenRequestCacheError","getCachedNativeRequest","cachedRequest","isInteractionInProgress","matchClientId","getInteractionInProgress","INTERACTION_STATUS_KEY","inProgress","INTERACTION_TYPE","SIGNIN","interactionInProgress","hydrateCache","result","request","idTokenEntity","createIdTokenEntity","environment","claimsHash","claims","hashString","accessTokenEntity","createAccessTokenEntity","scopes","join","expiresOn","TimeUtils","toSecondsFromDate","extExpiresOn","tokenType","sshKid","cacheRecord","saveCacheRecord","storeInCache","CacheError","addFields","cacheRtCount","cacheIdCount","cacheAtCount","SessionStorage","DEFAULT_BROWSER_CACHE_MANAGER","cacheOptions","cacheMigrationEnabled","claimsBasedCachingEnabled","DEFAULT_CRYPTO_IMPLEMENTATION"],"sources":["/Users/marieezoua/Documents/School Files/GSU/Spring 2025/CSC 4311 - Cloud Computing/Project/Nimbus-Todo/node_modules/@azure/msal-browser/src/cache/BrowserCacheManager.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AccessTokenEntity,\n    AccountEntity,\n    AccountInfo,\n    ActiveAccountFilters,\n    AppMetadataEntity,\n    AuthenticationScheme,\n    AuthorityMetadataEntity,\n    CacheError,\n    CacheHelpers,\n    CacheManager,\n    CacheRecord,\n    ClientAuthErrorCodes,\n    CommonAuthorizationUrlRequest,\n    Constants,\n    createClientAuthError,\n    CredentialType,\n    DEFAULT_CRYPTO_IMPLEMENTATION,\n    ICrypto,\n    IdTokenEntity,\n    invokeAsync,\n    IPerformanceClient,\n    Logger,\n    PerformanceEvents,\n    PersistentCacheKeys,\n    RefreshTokenEntity,\n    ServerTelemetryEntity,\n    StaticAuthorityOptions,\n    StoreInCache,\n    StringUtils,\n    ThrottlingEntity,\n    TimeUtils,\n    TokenKeys,\n} from \"@azure/msal-common/browser\";\nimport { CacheOptions } from \"../config/Configuration.js\";\nimport {\n    BrowserAuthErrorCodes,\n    createBrowserAuthError,\n} from \"../error/BrowserAuthError.js\";\nimport {\n    BrowserCacheLocation,\n    InMemoryCacheKeys,\n    INTERACTION_TYPE,\n    StaticCacheKeys,\n    TemporaryCacheKeys,\n} from \"../utils/BrowserConstants.js\";\nimport { LocalStorage } from \"./LocalStorage.js\";\nimport { SessionStorage } from \"./SessionStorage.js\";\nimport { MemoryStorage } from \"./MemoryStorage.js\";\nimport { IWindowStorage } from \"./IWindowStorage.js\";\nimport { NativeTokenRequest } from \"../broker/nativeBroker/NativeRequest.js\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult.js\";\nimport { SilentRequest } from \"../request/SilentRequest.js\";\nimport { SsoSilentRequest } from \"../request/SsoSilentRequest.js\";\nimport { RedirectRequest } from \"../request/RedirectRequest.js\";\nimport { PopupRequest } from \"../request/PopupRequest.js\";\nimport { base64Decode } from \"../encode/Base64Decode.js\";\nimport { base64Encode } from \"../encode/Base64Encode.js\";\nimport { CookieStorage } from \"./CookieStorage.js\";\nimport { getAccountKeys, getTokenKeys } from \"./CacheHelpers.js\";\nimport { EventType } from \"../event/EventType.js\";\nimport { EventHandler } from \"../event/EventHandler.js\";\n\n/**\n * This class implements the cache storage interface for MSAL through browser local or session storage.\n * Cookies are only used if storeAuthStateInCookie is true, and are only used for\n * parameters such as state and nonce, generally.\n */\nexport class BrowserCacheManager extends CacheManager {\n    // Cache configuration, either set by user or default values.\n    protected cacheConfig: Required<CacheOptions>;\n    // Window storage object (either local or sessionStorage)\n    protected browserStorage: IWindowStorage<string>;\n    // Internal in-memory storage object used for data used by msal that does not need to persist across page loads\n    protected internalStorage: MemoryStorage<string>;\n    // Temporary cache\n    protected temporaryCacheStorage: IWindowStorage<string>;\n    // Cookie storage\n    protected cookieStorage: CookieStorage;\n    // Logger instance\n    protected logger: Logger;\n    // Telemetry perf client\n    protected performanceClient: IPerformanceClient;\n    // Event Handler\n    private eventHandler: EventHandler;\n\n    constructor(\n        clientId: string,\n        cacheConfig: Required<CacheOptions>,\n        cryptoImpl: ICrypto,\n        logger: Logger,\n        performanceClient: IPerformanceClient,\n        eventHandler: EventHandler,\n        staticAuthorityOptions?: StaticAuthorityOptions\n    ) {\n        super(clientId, cryptoImpl, logger, staticAuthorityOptions);\n        this.cacheConfig = cacheConfig;\n        this.logger = logger;\n        this.internalStorage = new MemoryStorage();\n        this.browserStorage = getStorageImplementation(\n            clientId,\n            cacheConfig.cacheLocation,\n            logger,\n            performanceClient\n        );\n        this.temporaryCacheStorage = getStorageImplementation(\n            clientId,\n            cacheConfig.temporaryCacheLocation,\n            logger,\n            performanceClient\n        );\n        this.cookieStorage = new CookieStorage();\n\n        this.performanceClient = performanceClient;\n        this.eventHandler = eventHandler;\n    }\n\n    async initialize(correlationId: string): Promise<void> {\n        await this.browserStorage.initialize(correlationId);\n    }\n\n    /**\n     * Parses passed value as JSON object, JSON.parse() will throw an error.\n     * @param input\n     */\n    protected validateAndParseJson(jsonValue: string): object | null {\n        try {\n            const parsedJson = JSON.parse(jsonValue);\n            /**\n             * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\n             * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\n             * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\n             *\n             */\n            return parsedJson && typeof parsedJson === \"object\"\n                ? parsedJson\n                : null;\n        } catch (error) {\n            return null;\n        }\n    }\n\n    /**\n     * Reads account from cache, deserializes it into an account entity and returns it.\n     * If account is not found from the key, returns null and removes key from map.\n     * @param accountKey\n     * @returns\n     */\n    getAccount(accountKey: string): AccountEntity | null {\n        this.logger.trace(\"BrowserCacheManager.getAccount called\");\n        const serializedAccount = this.browserStorage.getUserData(accountKey);\n        if (!serializedAccount) {\n            this.removeAccountKeyFromMap(accountKey);\n            return null;\n        }\n\n        const parsedAccount = this.validateAndParseJson(serializedAccount);\n        if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {\n            this.removeAccountKeyFromMap(accountKey);\n            return null;\n        }\n\n        return CacheManager.toObject<AccountEntity>(\n            new AccountEntity(),\n            parsedAccount\n        );\n    }\n\n    /**\n     * set account entity in the platform cache\n     * @param account\n     */\n    async setAccount(\n        account: AccountEntity,\n        correlationId: string\n    ): Promise<void> {\n        this.logger.trace(\"BrowserCacheManager.setAccount called\");\n        const key = account.generateAccountKey();\n        await invokeAsync(\n            this.browserStorage.setUserData.bind(this.browserStorage),\n            PerformanceEvents.SetUserData,\n            this.logger,\n            this.performanceClient\n        )(key, JSON.stringify(account), correlationId);\n        const wasAdded = this.addAccountKeyToMap(key);\n\n        /**\n         * @deprecated - Remove this in next major version in favor of more consistent LOGIN event\n         */\n        if (\n            this.cacheConfig.cacheLocation ===\n                BrowserCacheLocation.LocalStorage &&\n            wasAdded\n        ) {\n            this.eventHandler.emitEvent(\n                EventType.ACCOUNT_ADDED,\n                undefined,\n                account.getAccountInfo()\n            );\n        }\n    }\n\n    /**\n     * Returns the array of account keys currently cached\n     * @returns\n     */\n    getAccountKeys(): Array<string> {\n        return getAccountKeys(this.browserStorage);\n    }\n\n    /**\n     * Add a new account to the key map\n     * @param key\n     */\n    addAccountKeyToMap(key: string): boolean {\n        this.logger.trace(\"BrowserCacheManager.addAccountKeyToMap called\");\n        this.logger.tracePii(\n            `BrowserCacheManager.addAccountKeyToMap called with key: ${key}`\n        );\n        const accountKeys = this.getAccountKeys();\n        if (accountKeys.indexOf(key) === -1) {\n            // Only add key if it does not already exist in the map\n            accountKeys.push(key);\n            this.browserStorage.setItem(\n                StaticCacheKeys.ACCOUNT_KEYS,\n                JSON.stringify(accountKeys)\n            );\n            this.logger.verbose(\n                \"BrowserCacheManager.addAccountKeyToMap account key added\"\n            );\n            return true;\n        } else {\n            this.logger.verbose(\n                \"BrowserCacheManager.addAccountKeyToMap account key already exists in map\"\n            );\n            return false;\n        }\n    }\n\n    /**\n     * Remove an account from the key map\n     * @param key\n     */\n    removeAccountKeyFromMap(key: string): void {\n        this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap called\");\n        this.logger.tracePii(\n            `BrowserCacheManager.removeAccountKeyFromMap called with key: ${key}`\n        );\n        const accountKeys = this.getAccountKeys();\n        const removalIndex = accountKeys.indexOf(key);\n        if (removalIndex > -1) {\n            accountKeys.splice(removalIndex, 1);\n            this.browserStorage.setItem(\n                StaticCacheKeys.ACCOUNT_KEYS,\n                JSON.stringify(accountKeys)\n            );\n            this.logger.trace(\n                \"BrowserCacheManager.removeAccountKeyFromMap account key removed\"\n            );\n        } else {\n            this.logger.trace(\n                \"BrowserCacheManager.removeAccountKeyFromMap key not found in existing map\"\n            );\n        }\n    }\n\n    /**\n     * Extends inherited removeAccount function to include removal of the account key from the map\n     * @param key\n     */\n    async removeAccount(key: string): Promise<void> {\n        void super.removeAccount(key);\n        this.removeAccountKeyFromMap(key);\n    }\n\n    /**\n     * Removes credentials associated with the provided account\n     * @param account\n     */\n    async removeAccountContext(account: AccountEntity): Promise<void> {\n        await super.removeAccountContext(account);\n\n        /**\n         * @deprecated - Remove this in next major version in favor of more consistent LOGOUT event\n         */\n        if (\n            this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage\n        ) {\n            this.eventHandler.emitEvent(\n                EventType.ACCOUNT_REMOVED,\n                undefined,\n                account.getAccountInfo()\n            );\n        }\n    }\n\n    /**\n     * Removes given idToken from the cache and from the key map\n     * @param key\n     */\n    removeIdToken(key: string): void {\n        super.removeIdToken(key);\n        this.removeTokenKey(key, CredentialType.ID_TOKEN);\n    }\n\n    /**\n     * Removes given accessToken from the cache and from the key map\n     * @param key\n     */\n    async removeAccessToken(key: string): Promise<void> {\n        void super.removeAccessToken(key);\n        this.removeTokenKey(key, CredentialType.ACCESS_TOKEN);\n    }\n\n    /**\n     * Removes given refreshToken from the cache and from the key map\n     * @param key\n     */\n    removeRefreshToken(key: string): void {\n        super.removeRefreshToken(key);\n        this.removeTokenKey(key, CredentialType.REFRESH_TOKEN);\n    }\n\n    /**\n     * Gets the keys for the cached tokens associated with this clientId\n     * @returns\n     */\n    getTokenKeys(): TokenKeys {\n        return getTokenKeys(this.clientId, this.browserStorage);\n    }\n\n    /**\n     * Adds the given key to the token key map\n     * @param key\n     * @param type\n     */\n    addTokenKey(key: string, type: CredentialType): void {\n        this.logger.trace(\"BrowserCacheManager addTokenKey called\");\n        const tokenKeys = this.getTokenKeys();\n\n        switch (type) {\n            case CredentialType.ID_TOKEN:\n                if (tokenKeys.idToken.indexOf(key) === -1) {\n                    this.logger.info(\n                        \"BrowserCacheManager: addTokenKey - idToken added to map\"\n                    );\n                    tokenKeys.idToken.push(key);\n                }\n                break;\n            case CredentialType.ACCESS_TOKEN:\n                if (tokenKeys.accessToken.indexOf(key) === -1) {\n                    this.logger.info(\n                        \"BrowserCacheManager: addTokenKey - accessToken added to map\"\n                    );\n                    tokenKeys.accessToken.push(key);\n                }\n                break;\n            case CredentialType.REFRESH_TOKEN:\n                if (tokenKeys.refreshToken.indexOf(key) === -1) {\n                    this.logger.info(\n                        \"BrowserCacheManager: addTokenKey - refreshToken added to map\"\n                    );\n                    tokenKeys.refreshToken.push(key);\n                }\n                break;\n            default:\n                this.logger.error(\n                    `BrowserCacheManager:addTokenKey - CredentialType provided invalid. CredentialType: ${type}`\n                );\n                throw createClientAuthError(\n                    ClientAuthErrorCodes.unexpectedCredentialType\n                );\n        }\n\n        this.browserStorage.setItem(\n            `${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`,\n            JSON.stringify(tokenKeys)\n        );\n    }\n\n    /**\n     * Removes the given key from the token key map\n     * @param key\n     * @param type\n     */\n    removeTokenKey(key: string, type: CredentialType): void {\n        this.logger.trace(\"BrowserCacheManager removeTokenKey called\");\n        const tokenKeys = this.getTokenKeys();\n\n        switch (type) {\n            case CredentialType.ID_TOKEN:\n                this.logger.infoPii(\n                    `BrowserCacheManager: removeTokenKey - attempting to remove idToken with key: ${key} from map`\n                );\n                const idRemoval = tokenKeys.idToken.indexOf(key);\n                if (idRemoval > -1) {\n                    this.logger.info(\n                        \"BrowserCacheManager: removeTokenKey - idToken removed from map\"\n                    );\n                    tokenKeys.idToken.splice(idRemoval, 1);\n                } else {\n                    this.logger.info(\n                        \"BrowserCacheManager: removeTokenKey - idToken does not exist in map. Either it was previously removed or it was never added.\"\n                    );\n                }\n                break;\n            case CredentialType.ACCESS_TOKEN:\n                this.logger.infoPii(\n                    `BrowserCacheManager: removeTokenKey - attempting to remove accessToken with key: ${key} from map`\n                );\n                const accessRemoval = tokenKeys.accessToken.indexOf(key);\n                if (accessRemoval > -1) {\n                    this.logger.info(\n                        \"BrowserCacheManager: removeTokenKey - accessToken removed from map\"\n                    );\n                    tokenKeys.accessToken.splice(accessRemoval, 1);\n                } else {\n                    this.logger.info(\n                        \"BrowserCacheManager: removeTokenKey - accessToken does not exist in map. Either it was previously removed or it was never added.\"\n                    );\n                }\n                break;\n            case CredentialType.REFRESH_TOKEN:\n                this.logger.infoPii(\n                    `BrowserCacheManager: removeTokenKey - attempting to remove refreshToken with key: ${key} from map`\n                );\n                const refreshRemoval = tokenKeys.refreshToken.indexOf(key);\n                if (refreshRemoval > -1) {\n                    this.logger.info(\n                        \"BrowserCacheManager: removeTokenKey - refreshToken removed from map\"\n                    );\n                    tokenKeys.refreshToken.splice(refreshRemoval, 1);\n                } else {\n                    this.logger.info(\n                        \"BrowserCacheManager: removeTokenKey - refreshToken does not exist in map. Either it was previously removed or it was never added.\"\n                    );\n                }\n                break;\n            default:\n                this.logger.error(\n                    `BrowserCacheManager:removeTokenKey - CredentialType provided invalid. CredentialType: ${type}`\n                );\n                throw createClientAuthError(\n                    ClientAuthErrorCodes.unexpectedCredentialType\n                );\n        }\n\n        this.browserStorage.setItem(\n            `${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`,\n            JSON.stringify(tokenKeys)\n        );\n    }\n\n    /**\n     * generates idToken entity from a string\n     * @param idTokenKey\n     */\n    getIdTokenCredential(idTokenKey: string): IdTokenEntity | null {\n        const value = this.browserStorage.getUserData(idTokenKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getIdTokenCredential: called, no cache hit\"\n            );\n            this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n            return null;\n        }\n\n        const parsedIdToken = this.validateAndParseJson(value);\n        if (!parsedIdToken || !CacheHelpers.isIdTokenEntity(parsedIdToken)) {\n            this.logger.trace(\n                \"BrowserCacheManager.getIdTokenCredential: called, no cache hit\"\n            );\n            this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n            return null;\n        }\n\n        this.logger.trace(\n            \"BrowserCacheManager.getIdTokenCredential: cache hit\"\n        );\n        return parsedIdToken as IdTokenEntity;\n    }\n\n    /**\n     * set IdToken credential to the platform cache\n     * @param idToken\n     */\n    async setIdTokenCredential(\n        idToken: IdTokenEntity,\n        correlationId: string\n    ): Promise<void> {\n        this.logger.trace(\"BrowserCacheManager.setIdTokenCredential called\");\n        const idTokenKey = CacheHelpers.generateCredentialKey(idToken);\n\n        await invokeAsync(\n            this.browserStorage.setUserData.bind(this.browserStorage),\n            PerformanceEvents.SetUserData,\n            this.logger,\n            this.performanceClient\n        )(idTokenKey, JSON.stringify(idToken), correlationId);\n\n        this.addTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n    }\n\n    /**\n     * generates accessToken entity from a string\n     * @param key\n     */\n    getAccessTokenCredential(accessTokenKey: string): AccessTokenEntity | null {\n        const value = this.browserStorage.getUserData(accessTokenKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\"\n            );\n            this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n            return null;\n        }\n        const parsedAccessToken = this.validateAndParseJson(value);\n        if (\n            !parsedAccessToken ||\n            !CacheHelpers.isAccessTokenEntity(parsedAccessToken)\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\"\n            );\n            this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n            return null;\n        }\n\n        this.logger.trace(\n            \"BrowserCacheManager.getAccessTokenCredential: cache hit\"\n        );\n        return parsedAccessToken as AccessTokenEntity;\n    }\n\n    /**\n     * set accessToken credential to the platform cache\n     * @param accessToken\n     */\n    async setAccessTokenCredential(\n        accessToken: AccessTokenEntity,\n        correlationId: string\n    ): Promise<void> {\n        this.logger.trace(\n            \"BrowserCacheManager.setAccessTokenCredential called\"\n        );\n        const accessTokenKey = CacheHelpers.generateCredentialKey(accessToken);\n        await invokeAsync(\n            this.browserStorage.setUserData.bind(this.browserStorage),\n            PerformanceEvents.SetUserData,\n            this.logger,\n            this.performanceClient\n        )(accessTokenKey, JSON.stringify(accessToken), correlationId);\n\n        this.addTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n    }\n\n    /**\n     * generates refreshToken entity from a string\n     * @param refreshTokenKey\n     */\n    getRefreshTokenCredential(\n        refreshTokenKey: string\n    ): RefreshTokenEntity | null {\n        const value = this.browserStorage.getUserData(refreshTokenKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\"\n            );\n            this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n            return null;\n        }\n        const parsedRefreshToken = this.validateAndParseJson(value);\n        if (\n            !parsedRefreshToken ||\n            !CacheHelpers.isRefreshTokenEntity(parsedRefreshToken)\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\"\n            );\n            this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n            return null;\n        }\n\n        this.logger.trace(\n            \"BrowserCacheManager.getRefreshTokenCredential: cache hit\"\n        );\n        return parsedRefreshToken as RefreshTokenEntity;\n    }\n\n    /**\n     * set refreshToken credential to the platform cache\n     * @param refreshToken\n     */\n    async setRefreshTokenCredential(\n        refreshToken: RefreshTokenEntity,\n        correlationId: string\n    ): Promise<void> {\n        this.logger.trace(\n            \"BrowserCacheManager.setRefreshTokenCredential called\"\n        );\n        const refreshTokenKey =\n            CacheHelpers.generateCredentialKey(refreshToken);\n        await invokeAsync(\n            this.browserStorage.setUserData.bind(this.browserStorage),\n            PerformanceEvents.SetUserData,\n            this.logger,\n            this.performanceClient\n        )(refreshTokenKey, JSON.stringify(refreshToken), correlationId);\n\n        this.addTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n    }\n\n    /**\n     * fetch appMetadata entity from the platform cache\n     * @param appMetadataKey\n     */\n    getAppMetadata(appMetadataKey: string): AppMetadataEntity | null {\n        const value = this.browserStorage.getItem(appMetadataKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAppMetadata: called, no cache hit\"\n            );\n            return null;\n        }\n\n        const parsedMetadata = this.validateAndParseJson(value);\n        if (\n            !parsedMetadata ||\n            !CacheHelpers.isAppMetadataEntity(appMetadataKey, parsedMetadata)\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAppMetadata: called, no cache hit\"\n            );\n            return null;\n        }\n\n        this.logger.trace(\"BrowserCacheManager.getAppMetadata: cache hit\");\n        return parsedMetadata as AppMetadataEntity;\n    }\n\n    /**\n     * set appMetadata entity to the platform cache\n     * @param appMetadata\n     */\n    setAppMetadata(appMetadata: AppMetadataEntity): void {\n        this.logger.trace(\"BrowserCacheManager.setAppMetadata called\");\n        const appMetadataKey = CacheHelpers.generateAppMetadataKey(appMetadata);\n        this.browserStorage.setItem(\n            appMetadataKey,\n            JSON.stringify(appMetadata)\n        );\n    }\n\n    /**\n     * fetch server telemetry entity from the platform cache\n     * @param serverTelemetryKey\n     */\n    getServerTelemetry(\n        serverTelemetryKey: string\n    ): ServerTelemetryEntity | null {\n        const value = this.browserStorage.getItem(serverTelemetryKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getServerTelemetry: called, no cache hit\"\n            );\n            return null;\n        }\n        const parsedEntity = this.validateAndParseJson(value);\n        if (\n            !parsedEntity ||\n            !CacheHelpers.isServerTelemetryEntity(\n                serverTelemetryKey,\n                parsedEntity\n            )\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getServerTelemetry: called, no cache hit\"\n            );\n            return null;\n        }\n\n        this.logger.trace(\"BrowserCacheManager.getServerTelemetry: cache hit\");\n        return parsedEntity as ServerTelemetryEntity;\n    }\n\n    /**\n     * set server telemetry entity to the platform cache\n     * @param serverTelemetryKey\n     * @param serverTelemetry\n     */\n    setServerTelemetry(\n        serverTelemetryKey: string,\n        serverTelemetry: ServerTelemetryEntity\n    ): void {\n        this.logger.trace(\"BrowserCacheManager.setServerTelemetry called\");\n        this.browserStorage.setItem(\n            serverTelemetryKey,\n            JSON.stringify(serverTelemetry)\n        );\n    }\n\n    /**\n     *\n     */\n    getAuthorityMetadata(key: string): AuthorityMetadataEntity | null {\n        const value = this.internalStorage.getItem(key);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAuthorityMetadata: called, no cache hit\"\n            );\n            return null;\n        }\n        const parsedMetadata = this.validateAndParseJson(value);\n        if (\n            parsedMetadata &&\n            CacheHelpers.isAuthorityMetadataEntity(key, parsedMetadata)\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAuthorityMetadata: cache hit\"\n            );\n            return parsedMetadata as AuthorityMetadataEntity;\n        }\n        return null;\n    }\n\n    /**\n     *\n     */\n    getAuthorityMetadataKeys(): Array<string> {\n        const allKeys = this.internalStorage.getKeys();\n        return allKeys.filter((key) => {\n            return this.isAuthorityMetadata(key);\n        });\n    }\n\n    /**\n     * Sets wrapper metadata in memory\n     * @param wrapperSKU\n     * @param wrapperVersion\n     */\n    setWrapperMetadata(wrapperSKU: string, wrapperVersion: string): void {\n        this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, wrapperSKU);\n        this.internalStorage.setItem(\n            InMemoryCacheKeys.WRAPPER_VER,\n            wrapperVersion\n        );\n    }\n\n    /**\n     * Returns wrapper metadata from in-memory storage\n     */\n    getWrapperMetadata(): [string, string] {\n        const sku =\n            this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) ||\n            Constants.EMPTY_STRING;\n        const version =\n            this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) ||\n            Constants.EMPTY_STRING;\n        return [sku, version];\n    }\n\n    /**\n     *\n     * @param entity\n     */\n    setAuthorityMetadata(key: string, entity: AuthorityMetadataEntity): void {\n        this.logger.trace(\"BrowserCacheManager.setAuthorityMetadata called\");\n        this.internalStorage.setItem(key, JSON.stringify(entity));\n    }\n\n    /**\n     * Gets the active account\n     */\n    getActiveAccount(): AccountInfo | null {\n        const activeAccountKeyFilters = this.generateCacheKey(\n            PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS\n        );\n        const activeAccountValueFilters = this.browserStorage.getItem(\n            activeAccountKeyFilters\n        );\n        if (!activeAccountValueFilters) {\n            this.logger.trace(\n                \"BrowserCacheManager.getActiveAccount: No active account filters found\"\n            );\n            return null;\n        }\n        const activeAccountValueObj = this.validateAndParseJson(\n            activeAccountValueFilters\n        ) as AccountInfo;\n        if (activeAccountValueObj) {\n            this.logger.trace(\n                \"BrowserCacheManager.getActiveAccount: Active account filters schema found\"\n            );\n            return this.getAccountInfoFilteredBy({\n                homeAccountId: activeAccountValueObj.homeAccountId,\n                localAccountId: activeAccountValueObj.localAccountId,\n                tenantId: activeAccountValueObj.tenantId,\n            });\n        }\n        this.logger.trace(\n            \"BrowserCacheManager.getActiveAccount: No active account found\"\n        );\n        return null;\n    }\n\n    /**\n     * Sets the active account's localAccountId in cache\n     * @param account\n     */\n    setActiveAccount(account: AccountInfo | null): void {\n        const activeAccountKey = this.generateCacheKey(\n            PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS\n        );\n        if (account) {\n            this.logger.verbose(\"setActiveAccount: Active account set\");\n            const activeAccountValue: ActiveAccountFilters = {\n                homeAccountId: account.homeAccountId,\n                localAccountId: account.localAccountId,\n                tenantId: account.tenantId,\n            };\n            this.browserStorage.setItem(\n                activeAccountKey,\n                JSON.stringify(activeAccountValue)\n            );\n        } else {\n            this.logger.verbose(\n                \"setActiveAccount: No account passed, active account not set\"\n            );\n            this.browserStorage.removeItem(activeAccountKey);\n        }\n        this.eventHandler.emitEvent(EventType.ACTIVE_ACCOUNT_CHANGED);\n    }\n\n    /**\n     * fetch throttling entity from the platform cache\n     * @param throttlingCacheKey\n     */\n    getThrottlingCache(throttlingCacheKey: string): ThrottlingEntity | null {\n        const value = this.browserStorage.getItem(throttlingCacheKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getThrottlingCache: called, no cache hit\"\n            );\n            return null;\n        }\n\n        const parsedThrottlingCache = this.validateAndParseJson(value);\n        if (\n            !parsedThrottlingCache ||\n            !CacheHelpers.isThrottlingEntity(\n                throttlingCacheKey,\n                parsedThrottlingCache\n            )\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getThrottlingCache: called, no cache hit\"\n            );\n            return null;\n        }\n\n        this.logger.trace(\"BrowserCacheManager.getThrottlingCache: cache hit\");\n        return parsedThrottlingCache as ThrottlingEntity;\n    }\n\n    /**\n     * set throttling entity to the platform cache\n     * @param throttlingCacheKey\n     * @param throttlingCache\n     */\n    setThrottlingCache(\n        throttlingCacheKey: string,\n        throttlingCache: ThrottlingEntity\n    ): void {\n        this.logger.trace(\"BrowserCacheManager.setThrottlingCache called\");\n        this.browserStorage.setItem(\n            throttlingCacheKey,\n            JSON.stringify(throttlingCache)\n        );\n    }\n\n    /**\n     * Gets cache item with given key.\n     * Will retrieve from cookies if storeAuthStateInCookie is set to true.\n     * @param key\n     */\n    getTemporaryCache(cacheKey: string, generateKey?: boolean): string | null {\n        const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n        if (this.cacheConfig.storeAuthStateInCookie) {\n            const itemCookie = this.cookieStorage.getItem(key);\n            if (itemCookie) {\n                this.logger.trace(\n                    \"BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies\"\n                );\n                return itemCookie;\n            }\n        }\n\n        const value = this.temporaryCacheStorage.getItem(key);\n        if (!value) {\n            // If temp cache item not found in session/memory, check local storage for items set by old versions\n            if (\n                this.cacheConfig.cacheLocation ===\n                BrowserCacheLocation.LocalStorage\n            ) {\n                const item = this.browserStorage.getItem(key);\n                if (item) {\n                    this.logger.trace(\n                        \"BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage\"\n                    );\n                    return item;\n                }\n            }\n            this.logger.trace(\n                \"BrowserCacheManager.getTemporaryCache: No cache item found in local storage\"\n            );\n            return null;\n        }\n        this.logger.trace(\n            \"BrowserCacheManager.getTemporaryCache: Temporary cache item returned\"\n        );\n        return value;\n    }\n\n    /**\n     * Sets the cache item with the key and value given.\n     * Stores in cookie if storeAuthStateInCookie is set to true.\n     * This can cause cookie overflow if used incorrectly.\n     * @param key\n     * @param value\n     */\n    setTemporaryCache(\n        cacheKey: string,\n        value: string,\n        generateKey?: boolean\n    ): void {\n        const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n\n        this.temporaryCacheStorage.setItem(key, value);\n        if (this.cacheConfig.storeAuthStateInCookie) {\n            this.logger.trace(\n                \"BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie\"\n            );\n            this.cookieStorage.setItem(\n                key,\n                value,\n                undefined,\n                this.cacheConfig.secureCookies\n            );\n        }\n    }\n\n    /**\n     * Removes the cache item with the given key.\n     * @param key\n     */\n    removeItem(key: string): void {\n        this.browserStorage.removeItem(key);\n    }\n\n    /**\n     * Removes the temporary cache item with the given key.\n     * Will also clear the cookie item if storeAuthStateInCookie is set to true.\n     * @param key\n     */\n    removeTemporaryItem(key: string): void {\n        this.temporaryCacheStorage.removeItem(key);\n        if (this.cacheConfig.storeAuthStateInCookie) {\n            this.logger.trace(\n                \"BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie\"\n            );\n            this.cookieStorage.removeItem(key);\n        }\n    }\n\n    /**\n     * Gets all keys in window.\n     */\n    getKeys(): string[] {\n        return this.browserStorage.getKeys();\n    }\n\n    /**\n     * Clears all cache entries created by MSAL.\n     */\n    async clear(): Promise<void> {\n        // Removes all accounts and their credentials\n        await this.removeAllAccounts();\n        this.removeAppMetadata();\n\n        // Remove temp storage first to make sure any cookies are cleared\n        this.temporaryCacheStorage.getKeys().forEach((cacheKey: string) => {\n            if (\n                cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 ||\n                cacheKey.indexOf(this.clientId) !== -1\n            ) {\n                this.removeTemporaryItem(cacheKey);\n            }\n        });\n\n        // Removes all remaining MSAL cache items\n        this.browserStorage.getKeys().forEach((cacheKey: string) => {\n            if (\n                cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 ||\n                cacheKey.indexOf(this.clientId) !== -1\n            ) {\n                this.browserStorage.removeItem(cacheKey);\n            }\n        });\n\n        this.internalStorage.clear();\n    }\n\n    /**\n     * Clears all access tokes that have claims prior to saving the current one\n     * @param performanceClient {IPerformanceClient}\n     * @param correlationId {string} correlation id\n     * @returns\n     */\n    async clearTokensAndKeysWithClaims(\n        performanceClient: IPerformanceClient,\n        correlationId: string\n    ): Promise<void> {\n        performanceClient.addQueueMeasurement(\n            PerformanceEvents.ClearTokensAndKeysWithClaims,\n            correlationId\n        );\n\n        const tokenKeys = this.getTokenKeys();\n\n        const removedAccessTokens: Array<Promise<void>> = [];\n        tokenKeys.accessToken.forEach((key: string) => {\n            // if the access token has claims in its key, remove the token key and the token\n            const credential = this.getAccessTokenCredential(key);\n            if (\n                credential?.requestedClaimsHash &&\n                key.includes(credential.requestedClaimsHash.toLowerCase())\n            ) {\n                removedAccessTokens.push(this.removeAccessToken(key));\n            }\n        });\n        await Promise.all(removedAccessTokens);\n\n        // warn if any access tokens are removed\n        if (removedAccessTokens.length > 0) {\n            this.logger.warning(\n                `${removedAccessTokens.length} access tokens with claims in the cache keys have been removed from the cache.`\n            );\n        }\n    }\n\n    /**\n     * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\n     * @param key\n     * @param addInstanceId\n     */\n    generateCacheKey(key: string): string {\n        const generatedKey = this.validateAndParseJson(key);\n        if (!generatedKey) {\n            if (StringUtils.startsWith(key, Constants.CACHE_PREFIX)) {\n                return key;\n            }\n            return `${Constants.CACHE_PREFIX}.${this.clientId}.${key}`;\n        }\n\n        return JSON.stringify(key);\n    }\n\n    /**\n     * Reset all temporary cache items\n     * @param state\n     */\n    resetRequestCache(): void {\n        this.logger.trace(\"BrowserCacheManager.resetRequestCache called\");\n\n        this.removeTemporaryItem(\n            this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS)\n        );\n        this.removeTemporaryItem(\n            this.generateCacheKey(TemporaryCacheKeys.VERIFIER)\n        );\n        this.removeTemporaryItem(\n            this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI)\n        );\n        this.removeTemporaryItem(\n            this.generateCacheKey(TemporaryCacheKeys.URL_HASH)\n        );\n        this.removeTemporaryItem(\n            this.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST)\n        );\n        this.setInteractionInProgress(false);\n    }\n\n    cacheAuthorizeRequest(\n        authCodeRequest: CommonAuthorizationUrlRequest,\n        codeVerifier?: string\n    ): void {\n        this.logger.trace(\"BrowserCacheManager.cacheAuthorizeRequest called\");\n\n        const encodedValue = base64Encode(JSON.stringify(authCodeRequest));\n        this.setTemporaryCache(\n            TemporaryCacheKeys.REQUEST_PARAMS,\n            encodedValue,\n            true\n        );\n\n        if (codeVerifier) {\n            const encodedVerifier = base64Encode(codeVerifier);\n            this.setTemporaryCache(\n                TemporaryCacheKeys.VERIFIER,\n                encodedVerifier,\n                true\n            );\n        }\n    }\n\n    /**\n     * Gets the token exchange parameters from the cache. Throws an error if nothing is found.\n     */\n    getCachedRequest(): [CommonAuthorizationUrlRequest, string] {\n        this.logger.trace(\"BrowserCacheManager.getCachedRequest called\");\n        // Get token request from cache and parse as TokenExchangeParameters.\n        const encodedTokenRequest = this.getTemporaryCache(\n            TemporaryCacheKeys.REQUEST_PARAMS,\n            true\n        );\n        if (!encodedTokenRequest) {\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.noTokenRequestCacheError\n            );\n        }\n        const encodedVerifier = this.getTemporaryCache(\n            TemporaryCacheKeys.VERIFIER,\n            true\n        );\n\n        let parsedRequest: CommonAuthorizationUrlRequest;\n        let verifier = \"\";\n        try {\n            parsedRequest = JSON.parse(base64Decode(encodedTokenRequest));\n            if (encodedVerifier) {\n                verifier = base64Decode(encodedVerifier);\n            }\n        } catch (e) {\n            this.logger.errorPii(`Attempted to parse: ${encodedTokenRequest}`);\n            this.logger.error(\n                `Parsing cached token request threw with error: ${e}`\n            );\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.unableToParseTokenRequestCacheError\n            );\n        }\n\n        return [parsedRequest, verifier];\n    }\n\n    /**\n     * Gets cached native request for redirect flows\n     */\n    getCachedNativeRequest(): NativeTokenRequest | null {\n        this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest called\");\n        const cachedRequest = this.getTemporaryCache(\n            TemporaryCacheKeys.NATIVE_REQUEST,\n            true\n        );\n        if (!cachedRequest) {\n            this.logger.trace(\n                \"BrowserCacheManager.getCachedNativeRequest: No cached native request found\"\n            );\n            return null;\n        }\n\n        const parsedRequest = this.validateAndParseJson(\n            cachedRequest\n        ) as NativeTokenRequest;\n        if (!parsedRequest) {\n            this.logger.error(\n                \"BrowserCacheManager.getCachedNativeRequest: Unable to parse native request\"\n            );\n            return null;\n        }\n\n        return parsedRequest;\n    }\n\n    isInteractionInProgress(matchClientId?: boolean): boolean {\n        const clientId = this.getInteractionInProgress()?.clientId;\n\n        if (matchClientId) {\n            return clientId === this.clientId;\n        } else {\n            return !!clientId;\n        }\n    }\n\n    getInteractionInProgress(): {\n        clientId: string;\n        type: INTERACTION_TYPE;\n    } | null {\n        const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\n        const value = this.getTemporaryCache(key, false);\n        return value ? JSON.parse(value) : null;\n    }\n\n    setInteractionInProgress(\n        inProgress: boolean,\n        type: INTERACTION_TYPE = INTERACTION_TYPE.SIGNIN\n    ): void {\n        // Ensure we don't overwrite interaction in progress for a different clientId\n        const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\n        if (inProgress) {\n            if (this.getInteractionInProgress()) {\n                throw createBrowserAuthError(\n                    BrowserAuthErrorCodes.interactionInProgress\n                );\n            } else {\n                // No interaction is in progress\n                this.setTemporaryCache(\n                    key,\n                    JSON.stringify({ clientId: this.clientId, type }),\n                    false\n                );\n            }\n        } else if (\n            !inProgress &&\n            this.getInteractionInProgress()?.clientId === this.clientId\n        ) {\n            this.removeTemporaryItem(key);\n        }\n    }\n\n    /**\n     * Builds credential entities from AuthenticationResult object and saves the resulting credentials to the cache\n     * @param result\n     * @param request\n     */\n    async hydrateCache(\n        result: AuthenticationResult,\n        request:\n            | SilentRequest\n            | SsoSilentRequest\n            | RedirectRequest\n            | PopupRequest\n    ): Promise<void> {\n        const idTokenEntity = CacheHelpers.createIdTokenEntity(\n            result.account?.homeAccountId,\n            result.account?.environment,\n            result.idToken,\n            this.clientId,\n            result.tenantId\n        );\n\n        let claimsHash;\n        if (request.claims) {\n            claimsHash = await this.cryptoImpl.hashString(request.claims);\n        }\n\n        /**\n         * meta data for cache stores time in seconds from epoch\n         * AuthenticationResult returns expiresOn and extExpiresOn in milliseconds (as a Date object which is in ms)\n         * We need to map these for the cache when building tokens from AuthenticationResult\n         *\n         * The next MSAL VFuture should map these both to same value if possible\n         */\n\n        const accessTokenEntity = CacheHelpers.createAccessTokenEntity(\n            result.account?.homeAccountId,\n            result.account.environment,\n            result.accessToken,\n            this.clientId,\n            result.tenantId,\n            result.scopes.join(\" \"),\n            // Access token expiresOn stored in seconds, converting from AuthenticationResult expiresOn stored as Date\n            result.expiresOn\n                ? TimeUtils.toSecondsFromDate(result.expiresOn)\n                : 0,\n            result.extExpiresOn\n                ? TimeUtils.toSecondsFromDate(result.extExpiresOn)\n                : 0,\n            base64Decode,\n            undefined, // refreshOn\n            result.tokenType as AuthenticationScheme,\n            undefined, // userAssertionHash\n            request.sshKid,\n            request.claims,\n            claimsHash\n        );\n\n        const cacheRecord = {\n            idToken: idTokenEntity,\n            accessToken: accessTokenEntity,\n        };\n        return this.saveCacheRecord(cacheRecord, result.correlationId);\n    }\n\n    /**\n     * saves a cache record\n     * @param cacheRecord {CacheRecord}\n     * @param storeInCache {?StoreInCache}\n     * @param correlationId {?string} correlation id\n     */\n    async saveCacheRecord(\n        cacheRecord: CacheRecord,\n        correlationId: string,\n        storeInCache?: StoreInCache\n    ): Promise<void> {\n        try {\n            await super.saveCacheRecord(\n                cacheRecord,\n                correlationId,\n                storeInCache\n            );\n        } catch (e) {\n            if (\n                e instanceof CacheError &&\n                this.performanceClient &&\n                correlationId\n            ) {\n                try {\n                    const tokenKeys = this.getTokenKeys();\n\n                    this.performanceClient.addFields(\n                        {\n                            cacheRtCount: tokenKeys.refreshToken.length,\n                            cacheIdCount: tokenKeys.idToken.length,\n                            cacheAtCount: tokenKeys.accessToken.length,\n                        },\n                        correlationId\n                    );\n                } catch (e) {}\n            }\n\n            throw e;\n        }\n    }\n}\n\n/**\n * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.\n * @param cacheLocation\n */\nfunction getStorageImplementation(\n    clientId: string,\n    cacheLocation: BrowserCacheLocation | string,\n    logger: Logger,\n    performanceClient: IPerformanceClient\n): IWindowStorage<string> {\n    try {\n        switch (cacheLocation) {\n            case BrowserCacheLocation.LocalStorage:\n                return new LocalStorage(clientId, logger, performanceClient);\n            case BrowserCacheLocation.SessionStorage:\n                return new SessionStorage();\n            case BrowserCacheLocation.MemoryStorage:\n            default:\n                break;\n        }\n    } catch (e) {\n        logger.error(e as string);\n    }\n\n    return new MemoryStorage();\n}\n\nexport const DEFAULT_BROWSER_CACHE_MANAGER = (\n    clientId: string,\n    logger: Logger,\n    performanceClient: IPerformanceClient,\n    eventHandler: EventHandler\n): BrowserCacheManager => {\n    const cacheOptions: Required<CacheOptions> = {\n        cacheLocation: BrowserCacheLocation.MemoryStorage,\n        temporaryCacheLocation: BrowserCacheLocation.MemoryStorage,\n        storeAuthStateInCookie: false,\n        secureCookies: false,\n        cacheMigrationEnabled: false,\n        claimsBasedCachingEnabled: false,\n    };\n    return new BrowserCacheManager(\n        clientId,\n        cacheOptions,\n        DEFAULT_CRYPTO_IMPLEMENTATION,\n        logger,\n        performanceClient,\n        eventHandler\n    );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}